#include "LcdTouchPad.h"
#include <intrins.h>
#include <absacc.h>
#include "FAT.h"
#include "SD.h"

uint T_x, T_y;
bit  bFileInUse;

// -----------------------------
// LCD basic operations
// -----------------------------
// basic LCD operations
void LCD_writeReg(uint index);
void LCD_writeData(uint val);
void LCD_writeCmd(uint index,uint val);
uint LCD_readData(void);

void LCD_setRamdomAddr(uint x,uint y)
{
	LCD_writeCmd(0x0020,x);	//set X pos
	LCD_writeCmd(0x0021,y);	//set Y pos
	LCD_writeReg(0x0022);
}

void LCD_writeReg(uint index)
{	
	LCD_RS =0;
	LCD_CS =0;	
	DPTR=index;				
#if bus
	DATA_H=DPH;
	DATA_L=DPL;
#else
	DATA_H=DPH;
	LCD_WR=0;
	LCD_WR=1;
	DATA_H=DPL;
#endif		
	LCD_WR =0;
	LCD_WR =1;
	LCD_RS =1;	
}

// basic LCD read/write data
void LCD_writeData(uint val)
{
	//LCD_RS =1;
	//LCD_CS =0;
	DPTR=val;						
#if bus
	DATA_H=DPH;
	DATA_L=DPL;
#else
	DATA_H=DPH;
	LCD_WR=0;
	LCD_WR=1;
	DATA_H=DPL;
#endif
	LCD_WR=0;
	LCD_WR=1;
	//LCD_CS =1;	
}

// basic LCD read/write command
void LCD_writeCmd(uint index,uint val)
{
	LCD_RS =0;
	LCD_CS =0;	
	DPTR=index;				
#if bus
	DATA_H=DPH;
	DATA_L=DPL;
#else
	DATA_H=DPH;
	LCD_WR=0;
	LCD_WR=1;
	DATA_H=DPL;
#endif		
	LCD_WR =0;
	LCD_WR =1;

	LCD_RS =1;
	DPTR=val;						
#if bus
	DATA_H=DPH;
	DATA_L=DPL;
#else
	DATA_H=DPH;
	LCD_WR=0;
	LCD_WR=1;
	DATA_H=DPL;
#endif						
	LCD_WR =0;
	LCD_WR =1;
	LCD_CS =1;
}

uint LCD_readData(void)              
{
	P0M0=0x00;
	P2M0=0x00;
	LCD_RS=1;
	DATA_H=0xff;
	DATA_L=0xff;
	LCD_CS=0;
	LCD_RD=0;
#if bus
	LCD_RD=1;
	DPH=DATA_H;
	DPL=DATA_L;
#else
	LCD_RD=1;
	DPH=DATA_H;
	LCD_RD=0;
	LCD_RD=1;
	DPL=DATA_H;
#endif
	P0M0=0xff;
	P2M0=0xff;
	LCD_CS=1;
	return DPTR;
}

void LCD_setWindow2(uchar startX, uint startY, uchar endX, uint endY)
{
	LCD_writeCmd(0x0050,startX);  // the start X
	LCD_writeCmd(0x0051,endX);    // the end X
	LCD_writeCmd(0x0052,startY);  // the start Y
	LCD_writeCmd(0x0053,endY);    //the end Y

	//move to the start position
	LCD_writeCmd(0x0020,startX);
	LCD_writeCmd(0x0021,startY);	
	LCD_writeReg(0x0022);
}

#define LCD_setWindow(startX, startY, width, height)      LCD_setWindow2(startX, startY, startX+width-1, startY+height-1)

// -----------------------------
// LCD
// -----------------------------
void LCD_init(void)
{
	uint t=0x9325;
	LCD_PWM=0;	
#if bus
	LCD_IM0=0;
#else
	LCD_IM0=1;
#endif

	LCD_RST=1;
	delayXms(254);	
	LCD_RST=0;
	delayXms(254);	
	LCD_RST=1;
	delayXms(254);	

	LCD_writeReg(0x0000);

	switch(LCD_readData())
	{
	case 0x9320:
		LCD_writeCmd(0x00E5, 0x8000); 	 // Set the internal vcore voltage
		LCD_writeCmd(0x0000, 0x0001); 	 // Start internal OSC.
		delayXms(40);
		LCD_writeCmd(0x0001, 0x0100);	 // set SS and SM bit
		LCD_writeCmd(0x0002, 0x0700);	 // set 1 line inveLCD_RSion

		LCD_writeCmd(0x0003, 0x1030);	 // set GRAM write direction and BGR=1.
		LCD_writeCmd(0x0060, 0x2700);		// Gate Scan Line

		LCD_writeCmd(0x0061, 0x0001);		// NDL,VLE, REV
		LCD_writeCmd(0x006A, 0x0000);		// set scrolling line

		LCD_writeCmd(0x0004, 0x0000);	 // Resize register

		LCD_writeCmd(0x0008, 0x0202);	 // set the back porch and front porch
		LCD_writeCmd(0x0009, 0x0000);	 // set non-display area refresh cycle ISC[3:0]
		LCD_writeCmd(0x000A, 0x0000);	 // FMARK function
		LCD_writeCmd(0x000C, 0x0000);		 // RGB interface setting
		LCD_writeCmd(0x000D, 0x0000);	 // Frame marker Position
		LCD_writeCmd(0x000F, 0x0000);		 // RGB interface polarity
		LCD_writeCmd(0x002b, 0x0020);   //frame rate and color control(0x0000)

		//*************Power On sequence ****************
		LCD_writeCmd(0x0010, 0x0000);		 // SAP, BT[3:0], AP, DSTB, SLP, STB
		LCD_writeCmd(0x0011, 0x0004);		 // DC1[2:0], DC0[2:0], VC[2:0]
		LCD_writeCmd(0x0012, 0x0000);		 // VREG1OUT voltage
		LCD_writeCmd(0x0013, 0x0000);		 // VDV[4:0] for VCOM amplitude
		delayXms(200);				// Dis-charge capacitor power voltage

		LCD_writeCmd(0x0010, 0x17B0);		 // SAP, BT[3:0], AP, DSTB, SLP, STB
		LCD_writeCmd(0x0011, 0x0037);		 // DC1[2:0], DC0[2:0], VC[2:0]
		delayXms(50);					 // Delay 50ms
		LCD_writeCmd(0x0012, 0x013E);		 // VREG1OUT voltage
		delayXms(50);					 // Delay 50ms
		LCD_writeCmd(0x0013, 0x1C00);		 // VDV[4:0] for VCOM amplitude
		LCD_writeCmd(0x0029, 0x000c);		 // VCM[4:0] for VCOMH
		delayXms(50);

#if 0
		// ----------- Adjust the Gamma	Curve-CM028 ----------//
		LCD_writeCmd(0x0030, 0x0007);
		LCD_writeCmd(0x0031, 0x0403);
		LCD_writeCmd(0x0032, 0x0404);
		LCD_writeCmd(0x0035, 0x0002);
		LCD_writeCmd(0x0036, 0x0707);
		LCD_writeCmd(0x0037, 0x0606);
		LCD_writeCmd(0x0038, 0x0106);
		LCD_writeCmd(0x0039, 0x0007);	
		LCD_writeCmd(0x003C, 0x0700);
		LCD_writeCmd(0x003D, 0x0707);
		// ----------- Adjust the Gamma	Curve-CM028 ----------//
		LCD_writeCmd(0x0030, 0x0007);
		LCD_writeCmd(0x0031, 0x0504);
		LCD_writeCmd(0x0032, 0x0703);
		LCD_writeCmd(0x0035, 0x0002);
		LCD_writeCmd(0x0036, 0x0707);
		LCD_writeCmd(0x0037, 0x0406);
		LCD_writeCmd(0x0038, 0x0006);
		LCD_writeCmd(0x0039, 0x0404);	
		LCD_writeCmd(0x003C, 0x0700);
		LCD_writeCmd(0x003D, 0x0A08);
#endif
		LCD_writeCmd(0x0030, 0x0000);
		LCD_writeCmd(0x0031, 0x0100);
		LCD_writeCmd(0x0032, 0x0000);
		LCD_writeCmd(0x0035, 0x0203);
		LCD_writeCmd(0x0036, 0x1008);
		LCD_writeCmd(0x0037, 0x0707);
		LCD_writeCmd(0x0038, 0x0305);
		LCD_writeCmd(0x0039, 0x0707);
		LCD_writeCmd(0x003C, 0x0302);
		LCD_writeCmd(0x003D, 0x1004);

		// ----------- Adjust the Gamma	Curve-CM028 ----------//
		break;

	default:
	case 0x9325:
		LCD_writeCmd(0x0000, 0x0001); 	 // Start internal OSC.
		delayXms(80);
		LCD_writeCmd(0x0001, 0x0100);	 // set SS and SM bit
		LCD_writeCmd(0x0002, 0x0700);	 // set 1 line inveLCD_RSion

		LCD_writeCmd(0x0003, 0x1030);	 // set GRAM write direction and BGR=1.
		LCD_writeCmd(0x0060, 0xA700);		// Gate Scan Line

		LCD_writeCmd(0x0061, 0x0001);		// NDL,VLE, REV
		LCD_writeCmd(0x006A, 0x0000);		// set scrolling line

		LCD_writeCmd(0x0004, 0x0000);	 // Resize register

		LCD_writeCmd(0x0008, 0x0207);	 // set the back porch and front porch
		LCD_writeCmd(0x0009, 0x0000);	 // set non-display area refresh cycle ISC[3:0]
		LCD_writeCmd(0x000A, 0x0000);	 // FMARK function
		LCD_writeCmd(0x000C, 0x0000);		 // RGB interface setting
		LCD_writeCmd(0x000D, 0x0000);	 // Frame marker Position
		LCD_writeCmd(0x000F, 0x0000);		 // RGB interface polarity
		//LCD_writeCmd(0x002b, 0x0020);   //frame rate and color control(0x0000)

		//*************Power On sequence ****************
		LCD_writeCmd(0x0010, 0x0000);		 // SAP, BT[3:0], AP, DSTB, SLP, STB
		LCD_writeCmd(0x0011, 0x0007);		 // DC1[2:0], DC0[2:0], VC[2:0]
		LCD_writeCmd(0x0012, 0x0000);		 // VREG1OUT voltage
		LCD_writeCmd(0x0013, 0x0000);		 // VDV[4:0] for VCOM amplitude
		delayXms(200);				// Dis-charge capacitor power voltage

		LCD_writeCmd(0x0007, 0x0101);		//
		LCD_writeCmd(0x0010, 0x12B0);		 // SAP, BT[3:0], AP, DSTB, SLP, STB
		LCD_writeCmd(0x0011, 0x0007);		 // DC1[2:0], DC0[2:0], VC[2:0]
		delayXms(50);					 // Delay 50ms
		LCD_writeCmd(0x0012, 0x01BB);		 // VREG1OUT voltage
		delayXms(50);					 // Delay 50ms
		LCD_writeCmd(0x0013, 0x1400);		 // VDV[4:0] for VCOM amplitude
		LCD_writeCmd(0x0029, 0x0010);		 // VCM[4:0] for VCOMH
		delayXms(50);

		// ----------- Adjust the Gamma Curve ----------//
		LCD_writeCmd(0x0030, 0x0000);
		LCD_writeCmd(0x0031, 0x0100);
		LCD_writeCmd(0x0032, 0x0000);
		LCD_writeCmd(0x0035, 0x0203);
		LCD_writeCmd(0x0036, 0x1008);
		LCD_writeCmd(0x0037, 0x0707);
		LCD_writeCmd(0x0038, 0x0305);
		LCD_writeCmd(0x0039, 0x0707);
		LCD_writeCmd(0x003C, 0x0302);
		LCD_writeCmd(0x003D, 0x1004);
		//CABC
		LCD_writeCmd(0x00E2,0x00E2);
		LCD_writeCmd(0x00B1,0x00FF);
		LCD_writeCmd(0x00B3,0x002C);
		LCD_writeCmd(0x00B5,0x0000);//0002
		break;

	case 0x9335:
		LCD_writeCmd(0x0000, 0x0001); 	 // Start internal OSC.
		delayXms(80);
		LCD_writeCmd(0x0001, 0x0100);	 // set SS and SM bit
		LCD_writeCmd(0x0002, 0x0700);	 // set 1 line inveLCD_RSion

		LCD_writeCmd(0x0003, 0x1030);	 // set GRAM write direction and BGR=1.
		LCD_writeCmd(0x0060, 0x2700);		// Gate Scan Line

		LCD_writeCmd(0x0061, 0x0001);		// NDL,VLE, REV
		LCD_writeCmd(0x006A, 0x0000);		// set scrolling line

		LCD_writeCmd(0x0004, 0x0000);	 // Resize register

		LCD_writeCmd(0x0008, 0x0207);	 // set the back porch and front porch
		LCD_writeCmd(0x0009, 0x0000);	 // set non-display area refresh cycle ISC[3:0]
		LCD_writeCmd(0x000A, 0x0000);	 // FMARK function
		LCD_writeCmd(0x000C, 0x0000);		 // RGB interface setting
		LCD_writeCmd(0x000D, 0x0000);	 // Frame marker Position
		LCD_writeCmd(0x000F, 0x0000);		 // RGB interface polarity
		//LCD_writeCmd(0x002b, 0x0020);   //frame rate and color control(0x0000)

		//*************Power On sequence ****************
		LCD_writeCmd(0x0010, 0x0000);		 // SAP, BT[3:0], AP, DSTB, SLP, STB
		LCD_writeCmd(0x0011, 0x0007);		 // DC1[2:0], DC0[2:0], VC[2:0]
		LCD_writeCmd(0x0012, 0x0000);		 // VREG1OUT voltage
		LCD_writeCmd(0x0013, 0x0000);		 // VDV[4:0] for VCOM amplitude
		delayXms(200);				// Dis-charge capacitor power voltage

		LCD_writeCmd(0x0007, 0x0101);		//
		LCD_writeCmd(0x0010, 0x12B0);		 // SAP, BT[3:0], AP, DSTB, SLP, STB
		LCD_writeCmd(0x0011, 0x0007);		 // DC1[2:0], DC0[2:0], VC[2:0]
		delayXms(50);					 // Delay 50ms
		LCD_writeCmd(0x0012, 0x01BB);		 // VREG1OUT voltage
		delayXms(50);					 // Delay 50ms
		LCD_writeCmd(0x0013, 0x1400);		 // VDV[4:0] for VCOM amplitude
		LCD_writeCmd(0x0029, 0x0010);		 // VCM[4:0] for VCOMH
		delayXms(50);

#if 0
		//----------2.8" Gamma  Curve table 1 ----------
		LCD_writeCmd(0x30, 0x000A);		
		LCD_writeCmd(0x31, 0x1326);		
		LCD_writeCmd(0x32, 0x0A29);
		LCD_writeCmd(0x33, 0x290A);
		LCD_writeCmd(0x34, 0x2613);
		LCD_writeCmd(0x35, 0x0A0A);		
		LCD_writeCmd(0x36, 0x1E03);		
		LCD_writeCmd(0x37, 0x031E);		
		LCD_writeCmd(0x38, 0x0706);		
		LCD_writeCmd(0x39, 0x0303);
		LCD_writeCmd(0x3A, 0x0E04);
		LCD_writeCmd(0x3B, 0x0E01);
		LCD_writeCmd(0x3C, 0x010E);		
		LCD_writeCmd(0x3D, 0x040E);
		LCD_writeCmd(0x3E, 0x0303);
		LCD_writeCmd(0x3F, 0x0607);
#else 
		//----------2.8" Gamma  Curve table 2 ----------
		LCD_writeCmd(0x30, 0x0b0d);
		LCD_writeCmd(0x31, 0x1923);
		LCD_writeCmd(0x32, 0x1c26);
		LCD_writeCmd(0x33, 0x261c);
		LCD_writeCmd(0x34, 0x2419);
		LCD_writeCmd(0x35, 0x0d0b);
		LCD_writeCmd(0x36, 0x1006);
		LCD_writeCmd(0x37, 0x0610);
		LCD_writeCmd(0x38, 0x0706);
		LCD_writeCmd(0x39, 0x0304);
		LCD_writeCmd(0x3A, 0x0e05);
		LCD_writeCmd(0x3B, 0x0e01);
		LCD_writeCmd(0x3C, 0x010e);
		LCD_writeCmd(0x3D, 0x050e);
		LCD_writeCmd(0x3E, 0x0403);
		LCD_writeCmd(0x3F, 0x0607);
#endif
		break;

	case 0x5408:
		LCD_writeCmd(0x0000, 0x0001); 	 // Start internal OSC.
		delayXms(80);
		LCD_writeCmd(0x0001, 0x0100);	 // set SS and SM bit
		LCD_writeCmd(0x0002, 0x0700);	 // set 1 line inveLCD_RSion

		LCD_writeCmd(0x0003, 0x5030);	 // set GRAM write direction and BGR=1.
		LCD_writeCmd(0x0060, 0xA700);		// Gate Scan Line

		LCD_writeCmd(0x0061, 0x0001);		// NDL,VLE, REV
		LCD_writeCmd(0x006A, 0x0000);		// set scrolling line

		LCD_writeCmd(0x0004, 0x0000);	 // Resize register

		LCD_writeCmd(0x0008, 0x0207);	 // set the back porch and front porch
		LCD_writeCmd(0x0009, 0x0000);	 // set non-display area refresh cycle ISC[3:0]
		LCD_writeCmd(0x000A, 0x0000);	 // FMARK function
		LCD_writeCmd(0x000C, 0x0000);		 // RGB interface setting
		LCD_writeCmd(0x000D, 0x0000);	 // Frame marker Position
		LCD_writeCmd(0x000F, 0x0000);		 // RGB interface polarity
		//LCD_writeCmd(0x002b, 0x0020);   //frame rate and color control(0x0000)

		//*************Power On sequence ****************
		LCD_writeCmd(0x0010, 0x0000);		 // SAP, BT[3:0], AP, DSTB, SLP, STB
		LCD_writeCmd(0x0011, 0x0007);		 // DC1[2:0], DC0[2:0], VC[2:0]
		LCD_writeCmd(0x0012, 0x0000);		 // VREG1OUT voltage
		LCD_writeCmd(0x0013, 0x0000);		 // VDV[4:0] for VCOM amplitude
		delayXms(200);				// Dis-charge capacitor power voltage

		LCD_writeCmd(0x0007, 0x0101);		//
		LCD_writeCmd(0x0010, 0x12B0);		 // SAP, BT[3:0], AP, DSTB, SLP, STB
		LCD_writeCmd(0x0011, 0x0007);		 // DC1[2:0], DC0[2:0], VC[2:0]
		delayXms(50);					 // Delay 50ms
		LCD_writeCmd(0x0012, 0x01BB);		 // VREG1OUT voltage
		delayXms(50);					 // Delay 50ms
		LCD_writeCmd(0x0013, 0x1400);		 // VDV[4:0] for VCOM amplitude
		LCD_writeCmd(0x0029, 0x0010);		 // VCM[4:0] for VCOMH
		delayXms(50);

#if 0
		//----------2.8" Gamma  Curve table 1 ----------
		LCD_writeCmd(0x30, 0x000A);		
		LCD_writeCmd(0x31, 0x1326);		
		LCD_writeCmd(0x32, 0x0A29);
		LCD_writeCmd(0x33, 0x290A);
		LCD_writeCmd(0x34, 0x2613);
		LCD_writeCmd(0x35, 0x0A0A);		
		LCD_writeCmd(0x36, 0x1E03);		
		LCD_writeCmd(0x37, 0x031E);		
		LCD_writeCmd(0x38, 0x0706);		
		LCD_writeCmd(0x39, 0x0303);
		LCD_writeCmd(0x3A, 0x0E04);
		LCD_writeCmd(0x3B, 0x0E01);
		LCD_writeCmd(0x3C, 0x010E);		
		LCD_writeCmd(0x3D, 0x040E);
		LCD_writeCmd(0x3E, 0x0303);
		LCD_writeCmd(0x3F, 0x0607);
#else 
		//----------2.8" Gamma  Curve table 2 ----------
		LCD_writeCmd(0x30, 0x0b0d);
		LCD_writeCmd(0x31, 0x1923);
		LCD_writeCmd(0x32, 0x1c26);
		LCD_writeCmd(0x33, 0x261c);
		LCD_writeCmd(0x34, 0x2419);
		LCD_writeCmd(0x35, 0x0d0b);
		LCD_writeCmd(0x36, 0x1006);
		LCD_writeCmd(0x37, 0x0610);
		LCD_writeCmd(0x38, 0x0706);
		LCD_writeCmd(0x39, 0x0304);
		LCD_writeCmd(0x3A, 0x0e05);
		LCD_writeCmd(0x3B, 0x0e01);
		LCD_writeCmd(0x3C, 0x010e);
		LCD_writeCmd(0x3D, 0x050e);
		LCD_writeCmd(0x3E, 0x0403);
		LCD_writeCmd(0x3F, 0x0607);
#endif
		break;
	}

	//------------------ Set GRAM area ---------------//
	LCD_writeCmd(0x0050, 0x0000);		// Horizontal GRAM Start Address
	LCD_writeCmd(0x0051, 0x00EF);		// Horizontal GRAM End Address
	LCD_writeCmd(0x0052, 0x0000);		// Vertical GRAM Start Address
	LCD_writeCmd(0x0053, 0x013F);		// Vertical GRAM Start Address

	//-------------- Partial Display Control ---------//
	LCD_writeCmd(0x0080, 0x0000);
	LCD_writeCmd(0x0081, 0x0000);
	LCD_writeCmd(0x0082, 0x0000);
	LCD_writeCmd(0x0083, 0x0000);
	LCD_writeCmd(0x0084, 0x0000);
	LCD_writeCmd(0x0085, 0x0000);

	//-------------- Panel Control -------------------//
	LCD_writeCmd(0x0090, 0x0010);
	LCD_writeCmd(0x0092, 0x0000);
	LCD_writeCmd(0x0093, 0x0103);
	LCD_writeCmd(0x0095, 0x0210);
	LCD_writeCmd(0x0097, 0x0000);
	LCD_writeCmd(0x0098, 0x0000);

	LCD_writeCmd(0x0007, 0x0173);		// 262K color and display ON
}

void LCD_fill(uint color, uchar startX, uint startY, uchar width, uint height)
{
	uint i;
	uchar j;
	EA =0;
	LCD_setWindow(startX, startY, width, height);
	for(i=0; i <height; i++)
	{
		for (j=0; j <width; j++)
			LCD_writeData(color);
	}
	EA =1;
}

#define HEADERSIZE_BMP 54
#define FILEBUF_PIX    40
#define COLOR_BMP24bit(r,g,b) (((((((uint)r)>>3)<<6)|(((uint)g)>>2))<<5)|(((uint)b)>>3)) // convert 24bit BMP to RGB565

bit LCD_showBMP24b(char* fnPattern, uchar idx, uchar startX, uint startY, uchar width, uint height)
{
	uint data i;
	uchar data j;
	uint data color;
	EA =0;
	if (FAT32_Open_File(&FileInfo, fnPattern, idx)) 
		return 0;

	bFileInUse = 1;
	LCD_setWindow(startX, startY, width, height);

//	for(i=0;i<1920;i++) //读取76800个点的颜色数据
	for (i=0; i < (uint) height /FILEBUF_PIX * width; i++) // read the width * height pixels by 120-byte or 40-pixel buffers
	{
//		FAT32_Read_File(&FileInfo,(ulong)i*120+54,120,file_buf);
		FAT32_Read_File(&FileInfo, (ulong)i *FILEBUF_PIX*3 +HEADERSIZE_BMP, FILEBUF_PIX*3, file_buf);
// 		for(j=0;j<40;j++)
		for (j=0; j <FILEBUF_PIX; j++)
		{	
			color = COLOR_BMP24bit(file_buf[3*j +2], file_buf[3*j +1], file_buf[3*j]);
			LCD_writeData(color);
		}
	}

	FAT32_File_Close(&FileInfo);
	bFileInUse = 0;
	EA =1;
	return 1;
}

bit LCD_showRGB565(char* fnPattern, uchar idx, uchar startX, uint startY, uchar width, uint height)
{
	uint i, j; //,temp;

	if (FAT32_Open_File(&FileInfo, fnPattern, idx)) 
		return 0;

	EA =0;
	bFileInUse = 1;
	LCD_setWindow(startX, startY, width, height);

	for (i=0; i< (uint) height /40 *width; i++) //?
	{
		FAT32_Read_File(&FileInfo, (ulong)i *FILEBUF_PIX*2, FILEBUF_PIX*2, file_buf);
		for (j=0; j <FILEBUF_PIX; j++)
		{
			// temp = ((uint)file_buf[j*2]) <<8 | file_buf[j*2 +1]; // MSBF
//			temp = ((uint)file_buf[j*2 +1])<<8 | file_buf[j*2]; // LSBF
//			LCD_writeData(temp);
			DPL = file_buf[j*2]; DPH = file_buf[j*2 +1]; // LSBF
			LCD_writeData(DPTR);
		}
	}

	FAT32_File_Close(&FileInfo); 
	bFileInUse = 0;
	EA =1;
	return 1;
}


uchar code AsciiFonts[]=  // the ascii table
{
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	//0
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x00,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x18,0x3C,0x7E,0x7E,0x7E,0x3C,0x18,0x00,0x00,0x00,0x00,0x00,0x00,
0xFF,0xFF,0xFF,0xE7,0xC3,0x81,0x81,0x81,0xC3,0xE7,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x1F,0x05,0x05,0x09,0x09,0x10,0x10,0x38,0x44,0x44,0x44,0x38,0x00,0x00,0x00,
0x00,0x1C,0x22,0x22,0x22,0x1C,0x08,0x08,0x7F,0x08,0x08,0x08,0x08,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x03,0x1D,0x11,0x13,0x1D,0x11,0x11,0x11,0x13,0x17,0x36,0x70,0x60,0x00,0x00,0x00,
0x08,0x08,0x5D,0x22,0x22,0x22,0x63,0x22,0x22,0x22,0x5D,0x08,0x08,0x00,0x00,0x00,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0xFF,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x00,
0x00,0x01,0x03,0x07,0x0F,0x1F,0x3F,0x7F,0x3F,0x1F,0x0F,0x07,0x03,0x01,0x00,0x00,
0x08,0x1C,0x2A,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x2A,0x1C,0x08,0x00,0x00,
0x00,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x00,0x00,0x24,0x24,0x00,0x00,
0x00,0x1F,0x25,0x45,0x45,0x45,0x25,0x1D,0x05,0x05,0x05,0x05,0x05,0x00,0x00,0x00,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x00,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0xF8,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x00,
0x08,0x1C,0x2A,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x00,0x00,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x0F,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x00,
0x00,0x00,0x00,0x00,0x00,0x04,0x02,0x7F,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x10,0x20,0x7F,0x20,0x10,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   
0x00,0x00,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x00,0x00,0x18,0x18,0x00,0x00,0x00,
0x12,0x36,0x24,0x48,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x24,0x24,0x24,0xFE,0x48,0x48,0x48,0xFE,0x48,0x48,0x48,0x00,0x00,0x00,
0x00,0x10,0x38,0x54,0x54,0x50,0x30,0x18,0x14,0x14,0x54,0x54,0x38,0x10,0x10,0x00,
0x00,0x00,0x44,0xA4,0xA8,0xA8,0xA8,0x54,0x1A,0x2A,0x2A,0x2A,0x44,0x00,0x00,0x00,
0x00,0x00,0x30,0x48,0x48,0x48,0x50,0x6E,0xA4,0x94,0x88,0x89,0x76,0x00,0x00,0x00,
0x60,0x60,0x20,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x02,0x04,0x08,0x08,0x10,0x10,0x10,0x10,0x10,0x10,0x08,0x08,0x04,0x02,0x00,0x00,
0x40,0x20,0x10,0x10,0x08,0x08,0x08,0x08,0x08,0x08,0x10,0x10,0x20,0x40,0x00,0x00,
0x00,0x00,0x00,0x10,0x10,0xD6,0x38,0x38,0xD6,0x10,0x10,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x10,0x10,0x10,0x10,0xFE,0x10,0x10,0x10,0x10,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x60,0x20,0xC0,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x60,0x00,0x00,0x00,
0x00,0x01,0x02,0x02,0x04,0x04,0x08,0x08,0x10,0x10,0x20,0x20,0x40,0x40,0x00,0x00,
0x00,0x00,0x18,0x24,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x24,0x18,0x00,0x00,0x00,
0x00,0x00,0x10,0x70,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x7C,0x00,0x00,0x00,
0x00,0x00,0x3C,0x42,0x42,0x42,0x04,0x04,0x08,0x10,0x20,0x42,0x7E,0x00,0x00,0x00,
0x00,0x00,0x3C,0x42,0x42,0x04,0x18,0x04,0x02,0x02,0x42,0x44,0x38,0x00,0x00,0x00,
0x00,0x00,0x04,0x0C,0x14,0x24,0x24,0x44,0x44,0x7E,0x04,0x04,0x1E,0x00,0x00,0x00,
0x00,0x00,0x7E,0x40,0x40,0x40,0x58,0x64,0x02,0x02,0x42,0x44,0x38,0x00,0x00,0x00,
0x00,0x00,0x1C,0x24,0x40,0x40,0x58,0x64,0x42,0x42,0x42,0x24,0x18,0x00,0x00,0x00,
0x00,0x00,0x7E,0x44,0x44,0x08,0x08,0x10,0x10,0x10,0x10,0x10,0x10,0x00,0x00,0x00,
0x00,0x00,0x3C,0x42,0x42,0x42,0x24,0x18,0x24,0x42,0x42,0x42,0x3C,0x00,0x00,0x00,
0x00,0x00,0x18,0x24,0x42,0x42,0x42,0x26,0x1A,0x02,0x02,0x24,0x38,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x10,0x10,0x20,0x00,
0x00,0x00,0x02,0x04,0x08,0x10,0x20,0x40,0x20,0x10,0x08,0x04,0x02,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0xFE,0x00,0x00,0x00,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x40,0x20,0x10,0x08,0x04,0x02,0x04,0x08,0x10,0x20,0x40,0x00,0x00,0x00,
0x00,0x00,0x3C,0x42,0x42,0x62,0x02,0x04,0x08,0x08,0x00,0x18,0x18,0x00,0x00,0x00,
0x00,0x00,0x38,0x44,0x5A,0xAA,0xAA,0xAA,0xAA,0xB4,0x42,0x44,0x38,0x00,0x00,0x00,
0x00,0x00,0x10,0x10,0x18,0x28,0x28,0x24,0x3C,0x44,0x42,0x42,0xE7,0x00,0x00,0x00,
0x00,0x00,0xF8,0x44,0x44,0x44,0x78,0x44,0x42,0x42,0x42,0x44,0xF8,0x00,0x00,0x00,
0x00,0x00,0x3E,0x42,0x42,0x80,0x80,0x80,0x80,0x80,0x42,0x44,0x38,0x00,0x00,0x00,
0x00,0x00,0xF8,0x44,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x44,0xF8,0x00,0x00,0x00,
0x00,0x00,0xFC,0x42,0x48,0x48,0x78,0x48,0x48,0x40,0x42,0x42,0xFC,0x00,0x00,0x00,
0x00,0x00,0xFC,0x42,0x48,0x48,0x78,0x48,0x48,0x40,0x40,0x40,0xE0,0x00,0x00,0x00,
0x00,0x00,0x3C,0x44,0x44,0x80,0x80,0x80,0x8E,0x84,0x44,0x44,0x38,0x00,0x00,0x00,
0x00,0x00,0xE7,0x42,0x42,0x42,0x42,0x7E,0x42,0x42,0x42,0x42,0xE7,0x00,0x00,0x00,
0x00,0x00,0x7C,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x7C,0x00,0x00,0x00,
0x00,0x00,0x3E,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x88,0xF0,0x00,
0x00,0x00,0xEE,0x44,0x48,0x50,0x70,0x50,0x48,0x48,0x44,0x44,0xEE,0x00,0x00,0x00,
0x00,0x00,0xE0,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x42,0xFE,0x00,0x00,0x00,
0x00,0x00,0xEE,0x6C,0x6C,0x6C,0x6C,0x54,0x54,0x54,0x54,0x54,0xD6,0x00,0x00,0x00,
0x00,0x00,0xC7,0x62,0x62,0x52,0x52,0x4A,0x4A,0x4A,0x46,0x46,0xE2,0x00,0x00,0x00,
0x00,0x00,0x38,0x44,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x44,0x38,0x00,0x00,0x00,
0x00,0x00,0xFC,0x42,0x42,0x42,0x42,0x7C,0x40,0x40,0x40,0x40,0xE0,0x00,0x00,0x00,
0x00,0x00,0x38,0x44,0x82,0x82,0x82,0x82,0x82,0xB2,0xCA,0x4C,0x38,0x06,0x00,0x00,
0x00,0x00,0xFC,0x42,0x42,0x42,0x7C,0x48,0x48,0x44,0x44,0x42,0xE3,0x00,0x00,0x00,
0x00,0x00,0x3E,0x42,0x42,0x40,0x20,0x18,0x04,0x02,0x42,0x42,0x7C,0x00,0x00,0x00,
0x00,0x00,0xFE,0x92,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x38,0x00,0x00,0x00,
0x00,0x00,0xE7,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x3C,0x00,0x00,0x00,
0x00,0x00,0xE7,0x42,0x42,0x44,0x24,0x24,0x28,0x28,0x18,0x10,0x10,0x00,0x00,0x00,
0x00,0x00,0xD6,0x92,0x92,0x92,0x92,0xAA,0xAA,0x6C,0x44,0x44,0x44,0x00,0x00,0x00,
0x00,0x00,0xE7,0x42,0x24,0x24,0x18,0x18,0x18,0x24,0x24,0x42,0xE7,0x00,0x00,0x00,
0x00,0x00,0xEE,0x44,0x44,0x28,0x28,0x10,0x10,0x10,0x10,0x10,0x38,0x00,0x00,0x00,
0x00,0x00,0x7E,0x84,0x04,0x08,0x08,0x10,0x20,0x20,0x42,0x42,0xFC,0x00,0x00,0x00,
0x1E,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x1E,0x00,0x00,
0x00,0x40,0x40,0x20,0x20,0x10,0x10,0x10,0x08,0x08,0x04,0x04,0x04,0x02,0x02,0x00,
0x78,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x78,0x00,0x00,
0x1C,0x22,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,
0x60,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x42,0x1E,0x22,0x42,0x42,0x3F,0x00,0x00,0x00,
0x00,0x00,0xC0,0x40,0x40,0x40,0x58,0x64,0x42,0x42,0x42,0x64,0x58,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x1C,0x22,0x40,0x40,0x40,0x22,0x1C,0x00,0x00,0x00,
0x00,0x00,0x06,0x02,0x02,0x02,0x1E,0x22,0x42,0x42,0x42,0x26,0x1B,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x42,0x7E,0x40,0x40,0x42,0x3C,0x00,0x00,0x00,
0x00,0x00,0x0F,0x11,0x10,0x10,0x7E,0x10,0x10,0x10,0x10,0x10,0x7C,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x3E,0x44,0x44,0x38,0x40,0x3C,0x42,0x42,0x3C,0x00,
0x00,0x00,0xC0,0x40,0x40,0x40,0x5C,0x62,0x42,0x42,0x42,0x42,0xE7,0x00,0x00,0x00,
0x00,0x00,0x30,0x30,0x00,0x00,0x70,0x10,0x10,0x10,0x10,0x10,0x7C,0x00,0x00,0x00,
0x00,0x00,0x0C,0x0C,0x00,0x00,0x1C,0x04,0x04,0x04,0x04,0x04,0x04,0x44,0x78,0x00,
0x00,0x00,0xC0,0x40,0x40,0x40,0x4E,0x48,0x50,0x68,0x48,0x44,0xEE,0x00,0x00,0x00,
0x00,0x00,0x70,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x7C,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x49,0x49,0x49,0x49,0x49,0xED,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0xDC,0x62,0x42,0x42,0x42,0x42,0xE7,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x42,0x42,0x42,0x42,0x42,0x3C,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0xD8,0x64,0x42,0x42,0x42,0x44,0x78,0x40,0xE0,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x1E,0x22,0x42,0x42,0x42,0x22,0x1E,0x02,0x07,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0xEE,0x32,0x20,0x20,0x20,0x20,0xF8,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x3E,0x42,0x40,0x3C,0x02,0x42,0x7C,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x10,0x10,0x7C,0x10,0x10,0x10,0x10,0x10,0x0C,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0xC6,0x42,0x42,0x42,0x42,0x46,0x3B,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0xE7,0x42,0x24,0x24,0x28,0x10,0x10,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0xD7,0x92,0x92,0xAA,0xAA,0x44,0x44,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x6E,0x24,0x18,0x18,0x18,0x24,0x76,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0xE7,0x42,0x24,0x24,0x28,0x18,0x10,0x10,0xE0,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x44,0x08,0x10,0x10,0x22,0x7E,0x00,0x00,0x00, 
0x03,0x04,0x04,0x04,0x04,0x04,0x08,0x04,0x04,0x04,0x04,0x04,0x04,0x03,0x00,0x00,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x00,
0x60,0x10,0x10,0x10,0x10,0x10,0x08,0x10,0x10,0x10,0x10,0x10,0x10,0x60,0x00,0x00,
0x4C,0x43,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};

void LCD_printFont(uint x, uint y, uchar *pFont, uchar fontW, uchar fontH, uint colorFront, uint colorBack, uchar mod)
{
	uchar i, j, k, bitInLastWB;
	uchar v;
	bitInLastWB = fontW %8;

	EA=0;
	for (i=0; i<fontH; i++)
	{
		LCD_setRamdomAddr(x,y+i);
		for (k =0; k < fontW/8; k++)
		{
			v = *pFont++;
			for (j=0; j<8; j++)
			{
				if ( v & 0x80 )     //0x80>>j
					LCD_writeData((uint)(colorFront&0xffff));
				else
				{
					if (NORMAL == mod) 
						LCD_writeData((uint)(colorBack&0xffff));
					else
						LCD_setRamdomAddr(x+k*8+j+1,y+i); 
				}

				v <<=1;
			} 
		}

		if (!bitInLastWB)
			continue;
		
		v = *pFont++;
		for (j=0; j<bitInLastWB; j++)
		{
			if ( v & 0x80 )     //0x80>>j
				LCD_writeData((uint)(colorFront&0xffff));
			else
			{
				if (NORMAL == mod) 
					LCD_writeData((uint)(colorBack&0xffff));
				else
					LCD_setRamdomAddr(x+k*8+j+1,y+i); 
			}

			v <<=1;
		} 
	}
	EA=1;
}

xdata uchar text_StartX=0, text_Width=LCD_WIDTH, offset_X=0, text_flags=0;
xdata uint text_StartY=0, text_Height=LCD_HEIGHT, offset_Y=0, text_color=RED, text_bgcolor=BLACK;

void LCD_setTextWindow(uchar startX, uint startY, uchar width, uint height, uint colorFront, uint colorBackground, uchar flags)
{
	text_StartX  = startX;
	text_StartY  = startY;
	text_Width   = width&0xfff8;
	text_Height  = height&0xfffffff0;
	text_color   = colorFront;
	text_bgcolor = colorBackground;
	text_flags   = flags & 0x7f;

	if (flags & 0x80)
	{
		offset_X = offset_Y = 0;
		LCD_fill(text_bgcolor, text_StartX, text_StartY, width, height);
	}
	LCD_setWindow(0, 0, LCD_WIDTH, LCD_HEIGHT);
}

void LCD_putc(uchar ch)
{
	if ('\r' == ch)
	{
		offset_X = 0;
		return;
	}

	if ('\n'==ch || offset_X +8 >text_Width)
	{
		offset_X = 0;
		offset_Y += 16;

		if (offset_Y>= text_Height)
			offset_Y = 0;

		LCD_fill(text_bgcolor, text_StartX, text_StartY+offset_Y, text_Width, 16);
		LCD_setWindow(0, 0, LCD_WIDTH, LCD_HEIGHT);
	}
	if ('\n'==ch) return;
	LCD_printFont(text_StartX +offset_X, text_StartY +offset_Y, AsciiFonts + ch*16, 8, 16, text_color, text_bgcolor, text_flags&0x1);
	offset_X +=8;
}

#define HZ_column 16
void LCD_putHZ3(uchar x, uint y, uint chChinese, bit openFile)
{
	uchar* ch = (uchar*) &chChinese;
	if (openFile && FAT32_Open_File(&FileInfo, "\\HZK16.HK", 0)) 
		return;
	bFileInUse = 1;

	chChinese = (uint)(ch[0]-0xa1)*94 + ch[1]-0xa1; // (94*(区码-1)+(位码-1))*32

	if (32 !=FAT32_Read_File(&FileInfo, (ulong)chChinese*32, 32, file_buf))
		; // switch to the blank instead
	if (openFile)
	{
		FAT32_File_Close(&FileInfo); 
		bFileInUse = 0;
	}

	LCD_printFont(x, y, file_buf, 16, 16, text_color, text_bgcolor, text_flags&0x1);
	offset_X +=HZ_column;
}	

void LCD_putHZ2(uint chChinese, bit openFile)
{
	if (offset_X +HZ_column >text_Width)
	{
		offset_X = 0;
		offset_Y += 16;

		if (offset_Y>= text_Height)
			offset_Y = 0;

		if (text_Height - offset_Y>16)
			LCD_fill(text_bgcolor, text_StartX, text_StartY+offset_Y, text_Width, 16);
		LCD_setWindow(0, 0, LCD_WIDTH, LCD_HEIGHT);
	}

	LCD_putHZ3(text_StartX +offset_X, text_StartY +offset_Y, chChinese, openFile);
	offset_X +=HZ_column;
}	

/*
void LCD_putHZ(uint chChinese)
{
	LCD_putHZ2(chChinese, 1);
/*
	uchar data i, h, libSz;
	h = (uchar) (chChinese >>8);
	libSz = sizeof(HzLib) / sizeof(HzLib[0]);

	for (i=0; i< libSz; i++)
	{
		if ((HzLib[i].cnchar[1]== (uchar)(chChinese &0xff)) && ((uchar)HzLib[i].cnchar[0]==h))
			break;
	}

	if (i >= libSz)
		i =0; // relocate to blank

	if (offset_X +HZ_column >text_Width)
	{
		offset_X = 0;
		offset_Y += 16;

		if (offset_Y> text_Height)
			offset_Y = 0;

		if (text_Height - offset_Y>16)
			LCD_fill(text_bgcolor, text_StartX, text_StartY+offset_Y, text_Width, 16);
		LCD_setWindow(text_StartX, text_StartY, LCD_WIDTH -1, LCD_HEIGHT -1);
	}

	LCD_printFont(text_StartX +offset_X, text_StartY +offset_Y, HzLib[i].Msk, 16, 16, text_color, text_bgcolor, text_flags&0x1);
	offset_X +=HZ_column;
}	
*/

//================================= 
void LCD_puts(uchar *pStr)
{
	bit ZKOpened=0;
	for(; *pStr; pStr++)
	{
		if (*pStr & 0x80) // chinese character?
		{
			if (!ZKOpened)
				ZKOpened = !FAT32_Open_File(&FileInfo, "\\HZK16.HK", 0);
			bFileInUse = ZKOpened;
			LCD_putHZ2(*((uint*)pStr), 0);
			pStr ++;
		}
		else   // as ASCII
			LCD_putc(*pStr);
	}
  
	if (ZKOpened)
		FAT32_File_Close(&FileInfo); 

	bFileInUse = 0;
}

//================================= 
void LCD_printNum(uint num)
{
	unsigned char str[5];

	str[0] = num/1000+0x30; num %= 1000;
	str[1] = num/100 +0x30; num %= 100;
	str[2] = num/10  +0x30; num %= 10;
	str[3] = num     +0x30;
	str[4] = '\0';

	LCD_puts(str);
}

code char hextable[] = "0123456789abcdef";

void LCD_printbyte(uchar num)
{
	LCD_putc(hextable[num>>4]);
	LCD_putc(hextable[num&0x0f]);
}

//================================= 
void LCD_showRGB565_0(uint x, uint y, uint w, uint h, const uchar *str)
{
	uint i,j; //,temp;
	LCD_setWindow(x,y,w,h);
	for(j=0;j<h;j++)
	{
		//LCD_setRamdomAddr(x,y+j);
		for(i=0; i<w; i++)
		{   
			//LCD_writeData(*(unsigned short *)(&str[(j*w+i)*2]));   //MSBF
//			temp=str[(j*w+i)*2+1]<<8;      //LSBF
//			temp|=str[(j*w+i)*2];
//			LCD_writeData(temp);
			DPL = str[(j*w+i)*2]; DPH = str[(j*w+i)*2+1]; // LSBF
			LCD_writeData(DPTR);

		}
	}
}

// --------------------------------------------------
// SPI operations
// --------------------------------------------------
void SPI_write(uchar x) 
{
#ifdef STC_SPI
	SPDAT = x;
	while(!(SPSTAT & 0x80));
	SPSTAT =0xC0;
#else
	uchar i;

	for (i=0; i<8; i++)
	{ 
		if (x & 0x80)
			SPI_DI=1;      //Send bit by bit(MSB First)
		else 
			SPI_DI=0;

		SPI_CLK=0;         //Clock low
		if(is_init)
			delayIOSet();

		SPI_CLK=1;        //Clock High
		if(is_init)
			delayIOSet();

		x <<=1;
	}
#endif
}

uchar SPI_read()
{ 
#ifdef STC_SPI
	SPDAT = 0xFF;
	while(!(SPSTAT&0x80));
	SPSTAT =0xC0;
	return SPDAT;
#else
	uchar temp=0;
	uchar i;
	for (i=0;i<8;i++)    //MSB First
	{
		SPI_DO=1;
		SPI_CLK=0;         //Clock Low
		if(is_init)
			delayIOSet(); 

		SPI_CLK=1;         //Clock High 
		if(is_init)
			delayIOSet();	

		temp=(temp<<1) | SPI_DO; 	  //read mmc data out pin 
	}

	return (temp);
#endif
}


// -----------------------------
// touch pad
// -----------------------------
void Touch_init(void)
{
	touch_CS=1;
	touch_DCLK=1;
	touch_DIN=1;
	touch_DOUT=1;
}

/*

void Touch_getXY(uint *x, uint *y) 
{
	touch_CS=1;
//	touch_DCLK=1;
//	touch_DIN=1;
//	touch_DOUT=1;
	delayIOSet();
	touch_CS  =0;
	

	SPI_write(CHX);   *x= SPI_read();
	SPI_write(CHY);   *y= SPI_read();

//	*x=Touch_read(CHX);
//	*y=Touch_read(CHY);
	touch_CS  =1; delayIOSet();
}

void Touch_getXY2(uint *x, uint *y) 
{
	uchar lb; uint w;
	touch_CS=1;
	touch_DCLK=1;
	touch_DIN=1;
	touch_DOUT=1;
	delayIOSet();
	touch_CS  =0;

	*x=Touch_read(CHX);
	*y=Touch_read(CHY);
//	SPI_write(CHX);  w= SPI_read(); lb = SPI_read(); w <<=4; w|=(lb>>=4)&0x0f; *x=w;
//	SPI_write(CHY);  w= SPI_read(); lb = SPI_read(); w <<=4; w|=(lb>>=4)&0x0f; *y=w;

	touch_CS  =1; delayIOSet();
}
*/

uint Touch_read(unsigned char cmd) 
{
	uchar i; uint temp=0;
	touch_CS  =1;
	touch_DIN =0;
	touch_DCLK=0;
	delayIOSet();
	touch_CS  =0;

	for(i=0; i<8; i++) 
	{
		touch_DIN = (cmd & 0x80) ? 1:0;
		cmd <<= 1;
		touch_DCLK=1;
		touch_DCLK=0;
	}

	touch_DIN=0;
	touch_DCLK=1;
	for(i=0; i<12; i++) 
	{
		touch_DCLK=0;         
		temp <<=1;
		if (touch_DOUT)
			temp++;
		touch_DCLK=1;
	}

	touch_CS=1;
	return(temp);
}

xdata int _LeftTopX     =LEFT_TOP_X;
xdata int _LeftTopY     =LEFT_TOP_Y;
xdata int _TpWidth      =RIGHT_BOTTOM_X - LEFT_TOP_X;
xdata int _TpHeight     =RIGHT_BOTTOM_Y - LEFT_TOP_Y;

void Touch_getXY2(uint *x, uint *y) 
{
	*x = *y = 0xffffffff;
#ifdef STC_SPI
	SPCTL = 0x00;	// disable the SPI because the touchpad is 12bit signal instead of 8bit
#endif // STC_SPI
	*x=Touch_read(CHX);
	*y=Touch_read(CHY);

#ifdef STC_SPI
	SPCTL = 0xdc;	// work as SPI host, ignore SS, start with low speed CPU_CLK/128
#endif // STC_SPI
}

bit Touch_getXY(uint *x, uint *y) 
{
	Touch_getXY2(x, y);

	// convert to the xy based on LCD
	*x = (uint)(((long)*x -_LeftTopX) * LCD_WIDTH / _TpWidth);
	*y = (uint)(((long)*y -_LeftTopY) * LCD_HEIGHT/ _TpHeight);

	return (*x >= 0 && *x<=LCD_WIDTH && *y >=0 && *y<= LCD_HEIGHT);
}

// -----------------------------
// keyboard
// -----------------------------
#define BUTTON_COLOR 0xFFE8
void KB_drawButtonFrame(uchar x, uint y, uchar width, uchar height, uchar up)
{
	if (up)
	{
		// draw a box with edges
		LCD_fill(BUTTON_COLOR, x+1, y+1, width-4, height-4);
		LCD_fill(BLACK, x, y, width-2, 1);
		LCD_fill(BLACK, x, y, 1, height-2);
		LCD_fill(BLACK, x+width-3, y, 1, height-2);
		LCD_fill(BLACK, x, y+height-3, width-2, 1);
		// add the shadow at right-bottom
		LCD_fill(GRAY, x+width-2, y+1, 1, height-2);
		LCD_fill(GRAY, x+width-1, y+2, 1, height-2);
		LCD_fill(GRAY, x+1, y+height-2, width-2, 1);
		LCD_fill(GRAY, x+2, y+height-1, width-2, 1);
	}
	else {
		// draw a box with edges
		LCD_fill(BUTTON_COLOR, x+3, y+3, width-4, height-4);
		LCD_fill(BLACK, x+2, y+2, width-2, 1);
		LCD_fill(BLACK, x+2, y+2, 1, height-2);
		LCD_fill(BLACK, x+width-1, y+2, 1, height-2);
		LCD_fill(BLACK, x+2, y+height-1, width-2, 1);
		// add the shadow at the left-top
		LCD_fill(GRAY, x, y, 1, height-2);
		LCD_fill(GRAY, x+1, y+1, 1, height-2);
		LCD_fill(GRAY, x, y, width-2, 1);
		LCD_fill(GRAY, x+1, y+1, width-2, 1);
	}

	LCD_setWindow(0, 0, LCD_WIDTH, LCD_HEIGHT);
}

void KB_drawButton(uint x, uint y, uchar width, uchar height, uchar* fontCode, uchar fontW, uchar fontH, uchar up)
{
	KB_drawButtonFrame(x, y, width, height, up);

	if (up)
	{
		// locate the position of char
		x += width/2 -2 - fontW/2;  // = x+ (w -4)/2
		y += height/2 -2 - fontH/2; // = y+ (h -4)/2
	}
	else {
		// locate the position of char
		x += width/2 +2 - fontW/2; // = x+ (w +4)/2
		y += height/2 +2 - fontH/2; // = y+ (h +4)/2
	}

	LCD_printFont(x-1, y-1, fontCode, fontW, fontH, GRAY,  BUTTON_COLOR, TRANSPARENT);
	LCD_printFont(x,   y,   fontCode, fontW, fontH, BLACK, BUTTON_COLOR, TRANSPARENT);
}

void KB_drawButton2(uchar x, uint y, uchar width, uchar height, char* str, bit up)
{
	uchar strlen, i; bit ZKOpened =0;

	KB_drawButtonFrame(x, y, width, height, up);

	if (!str)
		return;

	for (strlen=0; str[strlen]; strlen++);
	if (up)
	{
		// locate the position of char
		x += width/2 -2 - strlen*8/2;  // = x+ (w -4)/2
		y += height/2 -2 - 16/2; // = y+ (h -4)/2
	}
	else {
		// locate the position of char
		x += width/2 +2 - strlen*8/2; // = x+ (w +4)/2
		y += height/2 +2 - 16/2; // = y+ (h +4)/2
	}

	for (i=0; i< strlen; i++)
	{
		if (str[strlen] & 0x80) // chinese character?
		{
			if (!ZKOpened)
				ZKOpened = !FAT32_Open_File(&FileInfo, "\\HZK16.HK", 0);
			LCD_putHZ3(x, y, *((uint*)&str[i++]), 0);
			x +=8;
		}
		else LCD_printFont(x, y, AsciiFonts + str[i]*16, 8, 16, BLACK, BUTTON_COLOR, TRANSPARENT);
		
		x +=8;
	}

 	if (ZKOpened)
		FAT32_File_Close(&FileInfo); 
}

// -----------------------------
// Numpad
// -----------------------------
#define Numpad_FONT_WIDTH 24
#define Numpad_FONT_HEIGHT 41

code uchar numPad[] =
{
	// 文字:  1 
	/*--  Century Gothic26;  此字体下对应的点阵为：宽x高=20x41   --*/
	/*--  宽度不是8的倍数，现调整为：宽度x高度=24x41  --*/
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xF8,0x00,0x0F,0xF8,
	0x00,0x0F,0xF8,0x00,0x1F,0xF8,0x00,0x00,0xF8,0x00,0x00,0xF8,0x00,0x00,0xF8,0x00,
	0x00,0xF8,0x00,0x00,0xF8,0x00,0x00,0xF8,0x00,0x00,0xF8,0x00,0x00,0xF8,0x00,0x00,
	0xF8,0x00,0x00,0xF8,0x00,0x00,0xF8,0x00,0x00,0xF8,0x00,0x00,0xF8,0x00,0x00,0xF8,
	0x00,0x00,0xF8,0x00,0x00,0xF8,0x00,0x00,0xF8,0x00,0x00,0xF8,0x00,0x00,0xF8,0x00,
	0x00,0xF8,0x00,0x00,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	/*--  文字:  2  --*/
	/*--  Century Gothic26;  此字体下对应的点阵为：宽x高=20x41   --*/
	/*--  宽度不是8的倍数，现调整为：宽度x高度=24x41  --*/
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xFC,0x00,0x0F,0xFF,
	0x00,0x1F,0xFF,0x80,0x3F,0xFF,0x80,0x7F,0xBF,0xC0,0x7E,0x0F,0xC0,0x7E,0x07,0xC0,
	0x7C,0x07,0xC0,0x00,0x0F,0xC0,0x00,0x0F,0xC0,0x00,0x0F,0xC0,0x00,0x1F,0x80,0x00,
	0x3F,0x80,0x00,0x7F,0x00,0x00,0xFE,0x00,0x01,0xFC,0x00,0x03,0xF8,0x00,0x07,0xF0,
	0x00,0x0F,0xE0,0x00,0x1F,0xC0,0x00,0x3F,0x80,0x00,0x7F,0xFF,0xC0,0xFF,0xFF,0xC0,
	0xFF,0xFF,0xC0,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	/*--  文字:  3  --*/
	/*--  Century Gothic26;  此字体下对应的点阵为：宽x高=20x41   --*/
	/*--  宽度不是8的倍数，现调整为：宽度x高度=24x41  --*/
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFC,0x00,0x0F,0xFF,
	0x00,0x1F,0xFF,0x80,0x3F,0xFF,0xC0,0x3F,0x9F,0xC0,0x3F,0x0F,0xC0,0x00,0x07,0xC0,
	0x00,0x0F,0xC0,0x00,0x7F,0xC0,0x00,0xFF,0x80,0x00,0xFE,0x00,0x00,0xFF,0x00,0x00,
	0xFF,0xC0,0x00,0x7F,0xC0,0x00,0x0F,0xE0,0x00,0x07,0xE0,0x00,0x03,0xE0,0x7C,0x03,
	0xE0,0x7E,0x07,0xE0,0x7E,0x07,0xE0,0x7F,0x9F,0xE0,0x3F,0xFF,0xC0,0x1F,0xFF,0x80,
	0x0F,0xFF,0x00,0x07,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	/*--  文字:  *  --*/
	/*--  Century Gothic26;  此字体下对应的点阵为：宽x高=20x41   --*/
	/*--  宽度不是8的倍数，现调整为：宽度x高度=24x41  --*/
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x80,0x00,0x13,0x88,0x00,0x3B,0xB8,
	0x00,0x7F,0xFC,0x00,0x7F,0xFC,0x00,0x7F,0xFC,0x00,0x0F,0xE0,0x00,0x7F,0xFC,0x00,
	0x7F,0xFC,0x00,0x7F,0xFC,0x00,0x3B,0xB8,0x00,0x13,0x90,0x00,0x03,0x80,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	/*--  文字:  4  --*/
	/*--  Century Gothic26;  此字体下对应的点阵为：宽x高=20x41   --*/
	/*--  宽度不是8的倍数，现调整为：宽度x高度=24x41  --*/
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0x80,0x00,0x3F,
	0x80,0x00,0x7F,0x80,0x00,0x7F,0x80,0x00,0xFF,0x80,0x01,0xFF,0x80,0x01,0xFF,0x80,
	0x03,0xFF,0x80,0x07,0xFF,0x80,0x0F,0xEF,0x80,0x0F,0xEF,0x80,0x1F,0xCF,0x80,0x3F,
	0x8F,0x80,0x3F,0x0F,0x80,0x7F,0x0F,0x80,0x7E,0x0F,0x80,0x7F,0xFF,0xE0,0x7F,0xFF,
	0xE0,0x7F,0xFF,0xE0,0x7F,0xFF,0xE0,0x00,0x0F,0x80,0x00,0x0F,0x80,0x00,0x0F,0x80,
	0x00,0x0F,0x80,0x00,0x0F,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	/*--  文字:  5  --*/
	/*--  Century Gothic26;  此字体下对应的点阵为：宽x高=20x41   --*/
	/*--  宽度不是8的倍数，现调整为：宽度x高度=24x41  --*/
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xFF,0xC0,0x07,0xFF,
	0xC0,0x0F,0xFF,0xC0,0x0F,0xFF,0xC0,0x0F,0x80,0x00,0x0F,0x80,0x00,0x1F,0x80,0x00,
	0x1F,0x80,0x00,0x1F,0x00,0x00,0x1F,0xFC,0x00,0x3F,0xFE,0x00,0x3F,0xFF,0x00,0x3F,
	0xFF,0x80,0x3F,0xBF,0xC0,0x1E,0x0F,0xC0,0x00,0x0F,0xC0,0x00,0x07,0xC0,0x00,0x07,
	0xC0,0x00,0x0F,0xC0,0xFC,0x0F,0xC0,0xFF,0x3F,0xC0,0x7F,0xFF,0x80,0x3F,0xFF,0x00,
	0x1F,0xFE,0x00,0x0F,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	/*--  文字:  6  --*/
	/*--  Century Gothic26;  此字体下对应的点阵为：宽x高=20x41   --*/
	/*--  宽度不是8的倍数，现调整为：宽度x高度=24x41  --*/
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x00,0x00,0x7C,
	0x00,0x00,0x7E,0x00,0x00,0xFE,0x00,0x00,0xFC,0x00,0x01,0xFC,0x00,0x01,0xF8,0x00,
	0x03,0xF8,0x00,0x03,0xF0,0x00,0x07,0xF0,0x00,0x07,0xE0,0x00,0x0F,0xFC,0x00,0x0F,
	0xFF,0x00,0x1F,0xFF,0x80,0x1F,0xFF,0x80,0x3F,0x9F,0xC0,0x3F,0x0F,0xC0,0x3E,0x07,
	0xC0,0x3E,0x07,0xC0,0x3F,0x0F,0xC0,0x3F,0x9F,0xC0,0x1F,0xFF,0x80,0x1F,0xFF,0x80,
	0x0F,0xFF,0x00,0x03,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	/*--  文字:  0  --*/
	/*--  Century Gothic26;  此字体下对应的点阵为：宽x高=20x41   --*/
	/*--  宽度不是8的倍数，现调整为：宽度x高度=24x41  --*/
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFC,0x00,0x0F,0xFF,
	0x00,0x1F,0xFF,0x80,0x1F,0xFF,0x80,0x3F,0x9F,0xC0,0x3F,0x0F,0xC0,0x7E,0x07,0xE0,
	0x7E,0x07,0xE0,0x7E,0x07,0xE0,0x7E,0x07,0xE0,0x7C,0x03,0xE0,0x7C,0x03,0xE0,0x7C,
	0x03,0xE0,0x7C,0x03,0xE0,0x7C,0x03,0xE0,0x7E,0x07,0xE0,0x7E,0x07,0xE0,0x7E,0x07,
	0xE0,0x7E,0x07,0xE0,0x3F,0x0F,0xC0,0x3F,0x9F,0xC0,0x3F,0xFF,0x80,0x1F,0xFF,0x80,
	0x0F,0xFF,0x00,0x03,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	/*--  文字:  7  --*/
	/*--  Century Gothic26;  此字体下对应的点阵为：宽x高=20x41   --*/
	/*--  宽度不是8的倍数，现调整为：宽度x高度=24x41  --*/
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xFF,0xE0,0x3F,0xFF,
	0xE0,0x3F,0xFF,0xE0,0x3F,0xFF,0xE0,0x00,0x0F,0xC0,0x00,0x1F,0xC0,0x00,0x1F,0x80,
	0x00,0x3F,0x80,0x00,0x3F,0x00,0x00,0x7F,0x00,0x00,0x7E,0x00,0x00,0xFE,0x00,0x00,
	0xFC,0x00,0x01,0xFC,0x00,0x01,0xF8,0x00,0x03,0xF8,0x00,0x03,0xF0,0x00,0x07,0xF0,
	0x00,0x07,0xE0,0x00,0x0F,0xE0,0x00,0x0F,0xC0,0x00,0x1F,0xC0,0x00,0x1F,0x80,0x00,
	0x1F,0x80,0x00,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	/*--  文字:  8  --*/
	/*--  Century Gothic26;  此字体下对应的点阵为：宽x高=20x41   --*/
	/*--  宽度不是8的倍数，现调整为：宽度x高度=24x41  --*/
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFC,0x00,0x0F,0xFF,
	0x00,0x1F,0xFF,0x80,0x3F,0xFF,0xC0,0x3F,0x9F,0xC0,0x3F,0x0F,0xC0,0x3E,0x07,0xC0,
	0x3E,0x07,0xC0,0x3F,0x0F,0xC0,0x3F,0x9F,0xC0,0x1F,0xFF,0x80,0x0F,0xFF,0x00,0x1F,
	0xFF,0x80,0x3F,0xFF,0xC0,0x7F,0x9F,0xE0,0x7E,0x07,0xE0,0x7E,0x07,0xE0,0x7C,0x03,
	0xE0,0x7E,0x07,0xE0,0x7E,0x07,0xE0,0x7F,0x9F,0xE0,0x3F,0xFF,0xC0,0x3F,0xFF,0xC0,
	0x1F,0xFF,0x80,0x07,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	/*--  文字:  9  --*/
	/*--  Century Gothic26;  此字体下对应的点阵为：宽x高=20x41   --*/
	/*--  宽度不是8的倍数，现调整为：宽度x高度=24x41  --*/
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFC,0x00,0x0F,0xFF,
	0x00,0x1F,0xFF,0x80,0x1F,0xFF,0x80,0x3F,0x9F,0xC0,0x3F,0x0F,0xC0,0x3E,0x07,0xC0,
	0x3E,0x07,0xC0,0x3F,0x0F,0xC0,0x3F,0x9F,0xC0,0x1F,0xFF,0x80,0x1F,0xFF,0x80,0x0F,
	0xFF,0x00,0x03,0xFF,0x00,0x00,0x7E,0x00,0x00,0xFE,0x00,0x00,0xFC,0x00,0x01,0xFC,
	0x00,0x01,0xF8,0x00,0x03,0xF8,0x00,0x03,0xF0,0x00,0x07,0xF0,0x00,0x07,0xE0,0x00,
	0x03,0xE0,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	/*--  文字:  #  --*/
	/*--  Century Gothic26;  此字体下对应的点阵为：宽x高=20x41   --*/
	/*--  宽度不是8的倍数，现调整为：宽度x高度=24x41  --*/
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xE3,0x80,0x01,0xE7,0x80,0x01,0xE7,
	0x80,0x01,0xE7,0x80,0x01,0xE7,0x80,0x01,0xE7,0x80,0x01,0xC7,0x00,0x03,0xCF,0x00,
	0x3F,0xFF,0xF0,0x3F,0xFF,0xF0,0x3F,0xFF,0xF0,0x03,0xCF,0x00,0x03,0x8E,0x00,0x07,
	0x8E,0x00,0x7F,0xFF,0xE0,0x7F,0xFF,0xE0,0x7F,0xFF,0xE0,0x07,0x9E,0x00,0x07,0x9E,
	0x00,0x07,0x1C,0x00,0x0F,0x3C,0x00,0x0F,0x3C,0x00,0x0F,0x3C,0x00,0x0F,0x3C,0x00,
	0x0F,0x3C,0x00,0x0E,0x3C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00

};

code uchar Numpad_values[] = {
	'1', '2', '3', '*',
	'4', '5', '6', '0',
	'7', '8', '9', '#' }; 

#define Numpad_ButtonWH 60
#define Numpad_ButtonHC 3
#define Numpad_ButtonVC 4

#define Numpad_HEIGHT (Numpad_ButtonWH *Numpad_ButtonHC)
#define Numpad_STARTY (LCD_HEIGHT - Numpad_HEIGHT)

void Numpad_drawButton(char key, uchar up)
{
	char x=3, y=3;

	// determin the x, y, convert the key to index
	switch (key)
	{
	case '*': y = 0; break;
	case '0':  y = 1; break;
	case '#': y = 2; break;
	default:
		x = (key -'0' -1);
		y = x / 3;
		if (x <0 || y >2)
			return;
		x %=3;
		break;
	}

	KB_drawButton(x*Numpad_ButtonWH, y*Numpad_ButtonWH +Numpad_STARTY, Numpad_ButtonWH, Numpad_ButtonWH, numPad + Numpad_FONT_WIDTH/8 * Numpad_FONT_HEIGHT *(y*Numpad_ButtonVC +x), Numpad_FONT_WIDTH, Numpad_FONT_HEIGHT, up);
}

void Numpad_reset()
{
	uchar i;
//	LCD_fill(BUTTON_COLOR, 0, Numpad_STARTY, LCD_WIDTH, LCD_HEIGHT);
	for (i=0; i < Numpad_ButtonVC * Numpad_ButtonHC; i++)
		Numpad_drawButton(Numpad_values[i], 1);
}

uchar Numpad_xy2key(uint Lcd_x, uint Lcd_y)
{
	int tmpY = Lcd_y - (LCD_HEIGHT - Numpad_HEIGHT);
	if (tmpY < 0 || tmpY > Numpad_HEIGHT)
		return 0xf1;

	// conver X, Y to col and row of the numpad
	Lcd_x /= Numpad_ButtonWH;
	Lcd_y = tmpY / Numpad_ButtonWH;
//        LCD_printNum(200, 40, adX);  //debug
//        LCD_printNum(200, 60, adY); //debug
	if (Lcd_x <0 || Lcd_y <0 || Lcd_x >=Numpad_ButtonVC || Lcd_y >=Numpad_ButtonHC)
	    return 0xf2;
	return Numpad_values[Lcd_y*Numpad_ButtonVC + Lcd_x];
}

void Touch_beep();
void Touch_beepAndOff(uint tenMs);

uchar Numpad_readKey()
{
	uchar key = 0xff, tmp, i;
    Touch_getXY(&T_x, &T_y);
	tmp = Numpad_xy2key(T_x, T_y);
	for (i =0; !touch_INT && i<100; i++)
	{
		delayXms(50);
    	Touch_getXY(&T_x, &T_y);
		key = Numpad_xy2key(T_x, T_y);

		if (key != tmp || key >0xf0)
		{
			tmp = key; key = 0xff;
			continue;
		}
	
		// two reads got the same key
		Numpad_drawButton(key, 0);
		Touch_beep();
		while(!touch_INT);
		Touch_beepAndOff(10);
		Numpad_drawButton(key, 1);
		break;
	}

	return key;
}

void Touch_beep()
{
//	touch_BEEP = 0;
}

void Touch_beepAndOff(uint tenMs)
{
//	touch_BEEP = 0;
	while (tenMs--)
		delayXms(10);
//	touch_BEEP = 1;
}

